/*
 * THIS FILE WAS AUTOMATICALLY GENERATED, DO NOT EDIT.
 *
 * This file was generated by the dom/make_names.pl script.
 *
 * Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE COMPUTER, INC. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE COMPUTER, INC. OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "config.h"
#include "SVGElementFactory.h"

#include "SVGNames.h"
#include "SVGAElement.h"
#include "SVGAltGlyphElement.h"
#include "SVGAnimateElement.h"
#include "SVGAnimateColorElement.h"
#include "SVGAnimateMotionElement.h"
#include "SVGAnimateTransformElement.h"
#include "SVGCircleElement.h"
#include "SVGClipPathElement.h"
#include "SVGCursorElement.h"
#include "SVGDefsElement.h"
#include "SVGDescElement.h"
#include "SVGEllipseElement.h"
#include "SVGFEBlendElement.h"
#include "SVGFEColorMatrixElement.h"
#include "SVGFEComponentTransferElement.h"
#include "SVGFECompositeElement.h"
#include "SVGFEDiffuseLightingElement.h"
#include "SVGFEDisplacementMapElement.h"
#include "SVGFEDistantLightElement.h"
#include "SVGFEFloodElement.h"
#include "SVGFEFuncAElement.h"
#include "SVGFEFuncBElement.h"
#include "SVGFEFuncGElement.h"
#include "SVGFEFuncRElement.h"
#include "SVGFEGaussianBlurElement.h"
#include "SVGFEImageElement.h"
#include "SVGFEMergeElement.h"
#include "SVGFEMergeNodeElement.h"
#include "SVGFEMorphologyElement.h"
#include "SVGFEOffsetElement.h"
#include "SVGFEPointLightElement.h"
#include "SVGFESpecularLightingElement.h"
#include "SVGFESpotLightElement.h"
#include "SVGFETileElement.h"
#include "SVGFETurbulenceElement.h"
#include "SVGFilterElement.h"
#include "SVGFontElement.h"
#include "SVGFontFaceElement.h"
#include "SVGFontFaceFormatElement.h"
#include "SVGFontFaceNameElement.h"
#include "SVGFontFaceSrcElement.h"
#include "SVGFontFaceUriElement.h"
#include "SVGForeignObjectElement.h"
#include "SVGGElement.h"
#include "SVGGlyphElement.h"
#include "SVGHKernElement.h"
#include "SVGImageElement.h"
#include "SVGLineElement.h"
#include "SVGLinearGradientElement.h"
#include "SVGMarkerElement.h"
#include "SVGMaskElement.h"
#include "SVGMetadataElement.h"
#include "SVGMissingGlyphElement.h"
#include "SVGMPathElement.h"
#include "SVGPathElement.h"
#include "SVGPatternElement.h"
#include "SVGPolygonElement.h"
#include "SVGPolylineElement.h"
#include "SVGRadialGradientElement.h"
#include "SVGRectElement.h"
#include "SVGScriptElement.h"
#include "SVGSetElement.h"
#include "SVGStopElement.h"
#include "SVGStyleElement.h"
#include "SVGSVGElement.h"
#include "SVGSwitchElement.h"
#include "SVGSymbolElement.h"
#include "SVGTextElement.h"
#include "SVGTextPathElement.h"
#include "SVGTitleElement.h"
#include "SVGTRefElement.h"
#include "SVGTSpanElement.h"
#include "SVGUseElement.h"
#include "SVGViewElement.h"
#include <wtf/HashMap.h>

#if ENABLE(DASHBOARD_SUPPORT)
#include "Document.h"
#include "Settings.h"
#endif

namespace WebCore {

using namespace SVGNames;

typedef PassRefPtr<SVGElement> (*ConstructorFunction)(const QualifiedName&, Document*, bool createdByParser);
typedef HashMap<AtomicStringImpl*, ConstructorFunction> FunctionMap;

static FunctionMap* gFunctionMap = 0;

#if ENABLE(SVG)
static PassRefPtr<SVGElement> aConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGAElement(tagName, document);
}

static PassRefPtr<SVGElement> altglyphConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGAltGlyphElement(tagName, document);
}

static PassRefPtr<SVGElement> animateConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGAnimateElement(tagName, document);
}

static PassRefPtr<SVGElement> animatecolorConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGAnimateColorElement(tagName, document);
}

static PassRefPtr<SVGElement> animatemotionConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGAnimateMotionElement(tagName, document);
}

static PassRefPtr<SVGElement> animatetransformConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGAnimateTransformElement(tagName, document);
}

static PassRefPtr<SVGElement> circleConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGCircleElement(tagName, document);
}

static PassRefPtr<SVGElement> clippathConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGClipPathElement(tagName, document);
}

static PassRefPtr<SVGElement> cursorConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGCursorElement(tagName, document);
}

static PassRefPtr<SVGElement> defsConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGDefsElement(tagName, document);
}

static PassRefPtr<SVGElement> descConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGDescElement(tagName, document);
}

static PassRefPtr<SVGElement> ellipseConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGEllipseElement(tagName, document);
}

static PassRefPtr<SVGElement> feblendConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEBlendElement(tagName, document);
}

static PassRefPtr<SVGElement> fecolormatrixConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEColorMatrixElement(tagName, document);
}

static PassRefPtr<SVGElement> fecomponenttransferConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEComponentTransferElement(tagName, document);
}

static PassRefPtr<SVGElement> fecompositeConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFECompositeElement(tagName, document);
}

static PassRefPtr<SVGElement> fediffuselightingConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEDiffuseLightingElement(tagName, document);
}

static PassRefPtr<SVGElement> fedisplacementmapConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEDisplacementMapElement(tagName, document);
}

static PassRefPtr<SVGElement> fedistantlightConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEDistantLightElement(tagName, document);
}

static PassRefPtr<SVGElement> fefloodConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEFloodElement(tagName, document);
}

static PassRefPtr<SVGElement> fefuncaConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEFuncAElement(tagName, document);
}

static PassRefPtr<SVGElement> fefuncbConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEFuncBElement(tagName, document);
}

static PassRefPtr<SVGElement> fefuncgConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEFuncGElement(tagName, document);
}

static PassRefPtr<SVGElement> fefuncrConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEFuncRElement(tagName, document);
}

static PassRefPtr<SVGElement> fegaussianblurConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEGaussianBlurElement(tagName, document);
}

static PassRefPtr<SVGElement> feimageConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEImageElement(tagName, document);
}

static PassRefPtr<SVGElement> femergeConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEMergeElement(tagName, document);
}

static PassRefPtr<SVGElement> femergenodeConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEMergeNodeElement(tagName, document);
}

static PassRefPtr<SVGElement> femorphologyConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEMorphologyElement(tagName, document);
}

static PassRefPtr<SVGElement> feoffsetConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEOffsetElement(tagName, document);
}

static PassRefPtr<SVGElement> fepointlightConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFEPointLightElement(tagName, document);
}

static PassRefPtr<SVGElement> fespecularlightingConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFESpecularLightingElement(tagName, document);
}

static PassRefPtr<SVGElement> fespotlightConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFESpotLightElement(tagName, document);
}

static PassRefPtr<SVGElement> fetileConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFETileElement(tagName, document);
}

static PassRefPtr<SVGElement> feturbulenceConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFETurbulenceElement(tagName, document);
}

static PassRefPtr<SVGElement> filterConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFilterElement(tagName, document);
}

static PassRefPtr<SVGElement> fontConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFontElement(tagName, document);
}

static PassRefPtr<SVGElement> fontfaceConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFontFaceElement(tagName, document);
}

static PassRefPtr<SVGElement> fontfaceformatConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFontFaceFormatElement(tagName, document);
}

static PassRefPtr<SVGElement> fontfacenameConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFontFaceNameElement(tagName, document);
}

static PassRefPtr<SVGElement> fontfacesrcConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFontFaceSrcElement(tagName, document);
}

static PassRefPtr<SVGElement> fontfaceuriConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGFontFaceUriElement(tagName, document);
}

static PassRefPtr<SVGElement> foreignobjectConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGForeignObjectElement(tagName, document);
}

static PassRefPtr<SVGElement> gConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGGElement(tagName, document);
}

static PassRefPtr<SVGElement> glyphConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGGlyphElement(tagName, document);
}

static PassRefPtr<SVGElement> hkernConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGHKernElement(tagName, document);
}

static PassRefPtr<SVGElement> imageConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGImageElement(tagName, document);
}

static PassRefPtr<SVGElement> lineConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGLineElement(tagName, document);
}

static PassRefPtr<SVGElement> lineargradientConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGLinearGradientElement(tagName, document);
}

static PassRefPtr<SVGElement> markerConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGMarkerElement(tagName, document);
}

static PassRefPtr<SVGElement> maskConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGMaskElement(tagName, document);
}

static PassRefPtr<SVGElement> metadataConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGMetadataElement(tagName, document);
}

static PassRefPtr<SVGElement> missingglyphConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGMissingGlyphElement(tagName, document);
}

static PassRefPtr<SVGElement> mpathConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGMPathElement(tagName, document);
}

static PassRefPtr<SVGElement> pathConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGPathElement(tagName, document);
}

static PassRefPtr<SVGElement> patternConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGPatternElement(tagName, document);
}

static PassRefPtr<SVGElement> polygonConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGPolygonElement(tagName, document);
}

static PassRefPtr<SVGElement> polylineConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGPolylineElement(tagName, document);
}

static PassRefPtr<SVGElement> radialgradientConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGRadialGradientElement(tagName, document);
}

static PassRefPtr<SVGElement> rectConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGRectElement(tagName, document);
}

static PassRefPtr<SVGElement> scriptConstructor(const QualifiedName& tagName, Document* document, bool createdByParser)
{
    return new SVGScriptElement(tagName, document, createdByParser);
}

static PassRefPtr<SVGElement> setConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGSetElement(tagName, document);
}

static PassRefPtr<SVGElement> stopConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGStopElement(tagName, document);
}

static PassRefPtr<SVGElement> styleConstructor(const QualifiedName& tagName, Document* document, bool createdByParser)
{
    return new SVGStyleElement(tagName, document, createdByParser);
}

static PassRefPtr<SVGElement> svgConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGSVGElement(tagName, document);
}

static PassRefPtr<SVGElement> switchConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGSwitchElement(tagName, document);
}

static PassRefPtr<SVGElement> symbolConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGSymbolElement(tagName, document);
}

static PassRefPtr<SVGElement> textConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGTextElement(tagName, document);
}

static PassRefPtr<SVGElement> textpathConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGTextPathElement(tagName, document);
}

static PassRefPtr<SVGElement> titleConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGTitleElement(tagName, document);
}

static PassRefPtr<SVGElement> trefConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGTRefElement(tagName, document);
}

static PassRefPtr<SVGElement> tspanConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGTSpanElement(tagName, document);
}

static PassRefPtr<SVGElement> useConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGUseElement(tagName, document);
}

static PassRefPtr<SVGElement> viewConstructor(const QualifiedName& tagName, Document* document, bool)
{
    return new SVGViewElement(tagName, document);
}

#endif
#if ENABLE(SVG)
static void addTag(const QualifiedName& tag, ConstructorFunction func)
{
    gFunctionMap->set(tag.localName().impl(), func);
}

static void createFunctionMap()
{
    ASSERT(!gFunctionMap);

    // Create the table.
    gFunctionMap = new FunctionMap;
    
    // Populate it with constructor functions.
    addTag(aTag, aConstructor);
    addTag(altGlyphTag, altglyphConstructor);
    addTag(animateTag, animateConstructor);
    addTag(animateColorTag, animatecolorConstructor);
    addTag(animateMotionTag, animatemotionConstructor);
    addTag(animateTransformTag, animatetransformConstructor);
    addTag(circleTag, circleConstructor);
    addTag(clipPathTag, clippathConstructor);
    addTag(cursorTag, cursorConstructor);
    addTag(defsTag, defsConstructor);
    addTag(descTag, descConstructor);
    addTag(ellipseTag, ellipseConstructor);
    addTag(feBlendTag, feblendConstructor);
    addTag(feColorMatrixTag, fecolormatrixConstructor);
    addTag(feComponentTransferTag, fecomponenttransferConstructor);
    addTag(feCompositeTag, fecompositeConstructor);
    addTag(feDiffuseLightingTag, fediffuselightingConstructor);
    addTag(feDisplacementMapTag, fedisplacementmapConstructor);
    addTag(feDistantLightTag, fedistantlightConstructor);
    addTag(feFloodTag, fefloodConstructor);
    addTag(feFuncATag, fefuncaConstructor);
    addTag(feFuncBTag, fefuncbConstructor);
    addTag(feFuncGTag, fefuncgConstructor);
    addTag(feFuncRTag, fefuncrConstructor);
    addTag(feGaussianBlurTag, fegaussianblurConstructor);
    addTag(feImageTag, feimageConstructor);
    addTag(feMergeTag, femergeConstructor);
    addTag(feMergeNodeTag, femergenodeConstructor);
    addTag(feMorphologyTag, femorphologyConstructor);
    addTag(feOffsetTag, feoffsetConstructor);
    addTag(fePointLightTag, fepointlightConstructor);
    addTag(feSpecularLightingTag, fespecularlightingConstructor);
    addTag(feSpotLightTag, fespotlightConstructor);
    addTag(feTileTag, fetileConstructor);
    addTag(feTurbulenceTag, feturbulenceConstructor);
    addTag(filterTag, filterConstructor);
    addTag(fontTag, fontConstructor);
    addTag(font_faceTag, fontfaceConstructor);
    addTag(font_face_formatTag, fontfaceformatConstructor);
    addTag(font_face_nameTag, fontfacenameConstructor);
    addTag(font_face_srcTag, fontfacesrcConstructor);
    addTag(font_face_uriTag, fontfaceuriConstructor);
    addTag(foreignObjectTag, foreignobjectConstructor);
    addTag(gTag, gConstructor);
    addTag(glyphTag, glyphConstructor);
    addTag(hkernTag, hkernConstructor);
    addTag(imageTag, imageConstructor);
    addTag(lineTag, lineConstructor);
    addTag(linearGradientTag, lineargradientConstructor);
    addTag(markerTag, markerConstructor);
    addTag(maskTag, maskConstructor);
    addTag(metadataTag, metadataConstructor);
    addTag(missing_glyphTag, missingglyphConstructor);
    addTag(mpathTag, mpathConstructor);
    addTag(pathTag, pathConstructor);
    addTag(patternTag, patternConstructor);
    addTag(polygonTag, polygonConstructor);
    addTag(polylineTag, polylineConstructor);
    addTag(radialGradientTag, radialgradientConstructor);
    addTag(rectTag, rectConstructor);
    addTag(scriptTag, scriptConstructor);
    addTag(setTag, setConstructor);
    addTag(stopTag, stopConstructor);
    addTag(styleTag, styleConstructor);
    addTag(svgTag, svgConstructor);
    addTag(switchTag, switchConstructor);
    addTag(symbolTag, symbolConstructor);
    addTag(textTag, textConstructor);
    addTag(textPathTag, textpathConstructor);
    addTag(titleTag, titleConstructor);
    addTag(trefTag, trefConstructor);
    addTag(tspanTag, tspanConstructor);
    addTag(useTag, useConstructor);
    addTag(viewTag, viewConstructor);
}
#endif

PassRefPtr<SVGElement> SVGElementFactory::createSVGElement(const QualifiedName& qName, Document* document, bool createdByParser)
{
#if ENABLE(SVG)
    if (!document)
        return 0;

#if ENABLE(DASHBOARD_SUPPORT)
    Settings* settings = document->settings();
    if (settings && settings->usesDashboardBackwardCompatibilityMode())
        return 0;
#endif
    if (!gFunctionMap)
        createFunctionMap();
    if (ConstructorFunction function = gFunctionMap->get(qName.localName().impl()))
        return function(qName, document, createdByParser);
    return SVGElement::create(qName, document);
#else
    return 0;
#endif
}

} // namespace WebCore

